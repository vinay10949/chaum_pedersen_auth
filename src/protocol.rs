use num_bigint::BigUint;

/// Defines the interface for a Zero-Knowledge Proof protocol.
///
/// This trait allows for different implementations of ZKP schemes to be used interchangeably.
/// It defines the core operations required for a protocol:
/// - Computing commitments (first move)
/// - Computing response (third move)
/// - Verifying the proof
pub trait ZKPProtocol {
    /// Computes the commitments for the ZKP.
    ///
    /// # Arguments
    ///
    /// * `randomness` - The random value used to generate the commitments.
    ///
    /// # Returns
    ///
    /// A tuple containing the two commitment values (r1, r2).
    fn compute_commitments(&self, randomness: &BigUint) -> (BigUint, BigUint);

    /// Computes the response to the challenge.
    ///
    /// # Arguments
    ///
    /// * `randomness` - The random value used in the commitment step.
    /// * `challenge` - The challenge value received from the verifier.
    /// * `secret` - The secret value being proven.
    ///
    /// # Returns
    ///
    /// The calculated response value `s`.
    fn compute_response(
        &self,
        randomness: &BigUint,
        challenge: &BigUint,
        secret: &BigUint,
    ) -> BigUint;

    /// Verifies the validity of the proof.
    ///
    /// # Arguments
    ///
    /// * `commitments` - The commitments (r1, r2) generated by the prover.
    /// * `challenge` - The challenge value sent by the verifier.
    /// * `response` - The response value calculated by the prover.
    /// * `public_values` - The calculated public values (y1, y2) associated with the secret.
    ///
    /// # Returns
    ///
    /// `true` if the proof is valid, `false` otherwise.
    fn verify(
        &self,
        commitments: (&BigUint, &BigUint),
        challenge: &BigUint,
        response: &BigUint,
        public_keys: (&BigUint, &BigUint),
    ) -> bool;

    /// Computes the public keys corresponding to a given secret.
    ///
    /// # Arguments
    ///
    /// * `secret` - The secret value.
    ///
    /// # Returns
    ///
    /// A tuple containing the two public keys (y1, y2).
    fn compute_public_values(&self, secret: &BigUint) -> (BigUint, BigUint);

    /// Returns the order of the group used in the protocol.
    ///
    /// # Returns
    ///
    /// A reference to the order `q`.
    fn get_order(&self) -> &BigUint;
}
